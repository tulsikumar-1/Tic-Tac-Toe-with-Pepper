# -*- coding: utf-8 -*-
"""tic3_planner.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1vge3L4YUQXIaGscAcGUa-FQ6ABdQH4g9
"""

def get_empty_cells(board):
    """Returns a list of empty cells on the board."""
    return [i for i, cell in enumerate(board) if cell == "."]

def is_winner(board, player):
    """Checks if the given player has won the game."""
    winning_combinations = [
        [0, 1, 2], [3, 4, 5], [6, 7, 8],  # rows
        [0, 3, 6], [1, 4, 7], [2, 5, 8],  # columns
        [0, 4, 8], [2, 4, 6]  # diagonals
    ]
    for combination in winning_combinations:
        if all(board[i] == player for i in combination):
            return True
    return False

def is_board_full(board):
    """Checks if the board is full and there is no winner."""
    return "." not in board

def minimax(board, depth, maximizing_player):
    """Minimax algorithm to determine the best move for the AI."""
    if is_winner(board, "X"):
        return 1
    elif is_winner(board, "O"):
        return -1
    elif is_board_full(board):
        return 0

    if maximizing_player:
        max_eval = float("-inf")
        for cell in get_empty_cells(board):
            new_board = board[:]
            new_board[cell] = "X"
            eval_score = minimax(new_board, depth + 1, False)
            max_eval = max(max_eval, eval_score)
        return max_eval
    else:
        min_eval = float("inf")
        for cell in get_empty_cells(board):
            new_board = board[:]
            new_board[cell] = "O"
            eval_score = minimax(new_board, depth + 1, True)
            min_eval = min(min_eval, eval_score)
        return min_eval

def generate_game_plan(board, player):
    """Generates an offline game tree plan for Tic Tac Toe."""
    game_plan = []

    if is_winner(board, "X"):
        game_plan.append([board.copy()])
        return game_plan
    elif is_winner(board, "O"):
        game_plan.append([board.copy()])
        return game_plan
    elif is_board_full(board):
        game_plan.append([board.copy()])
        return game_plan

    if player == "X":
        best_score = float("-inf")
        for cell in get_empty_cells(board):
            new_board = board.copy()
            new_board[cell] = "X"
            eval_score = minimax(new_board, 0, False)
            if eval_score > best_score:
                best_score = eval_score
                best_move = cell
        board[best_move] = "X"
        sub_plans = generate_game_plan(board, "O")
        for sub_plan in sub_plans:
            game_plan.append([board.copy()] + sub_plan)
        board[best_move] = "."  # Reset the cell after exploration
    else:
        for cell in get_empty_cells(board):
            new_board = board.copy()
            new_board[cell] = "O"
            sub_plans = generate_game_plan(new_board, "X")
            for sub_plan in sub_plans:
                game_plan.append([new_board.copy()] + sub_plan)

    return game_plan

# Example usage
initial_board = ["."] * 9
game_plans = generate_game_plan(initial_board, "X")
print("Total generate plans are:",len(game_plans))
# Remove duplicates using a loop
unique_moves = []
for plan in game_plans:
  for move in plan:
      if move not in unique_moves:
          unique_moves.append(move)
          #print(move)

print("Total Unique Moves:", len(unique_moves))

def get_pepper_move(state,game_plans):
  max_score = 0
  best_move = None
  move_index=None
  for plan in game_plans:
    for  move in plan:
      score = 0
      if move.count(".") < state.count(".") and move.count("O") == state.count("O"):
          for item1, item2 in zip(move, state):
              if (item1 == item2 == "O") or (item1 == item2 == "X")  :
                  score += 1
      if score > max_score:
          max_score = score
          best_move = move
  #print(best_move)
  for index, (item1, item2) in enumerate(zip(best_move, state)):
    if item1 == "X" and item2 == ".":

      #print(index)
      row = (index // 3)
      col = (index % 3)

  return (row,col)

#get_pepper_move(['X', '.', 'O', 'X', '.', 'O', 'X', '.', 'O'],game_plans)

import json
# Convert data to a JSON-compatible format
json_data = json.dumps(game_plans)

# Save JSON data to a file
with open('game_plans_3x.json', 'w') as file:
    file.write(json_data)
print("plans are saved in |game_plans_3x.json|")